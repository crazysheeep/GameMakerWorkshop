
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>The Beginner's Guide to the UNIXverse</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="author" content="">

        <!-- styles -->
        <link href="./assets/css/bootstrap.min.css" rel="stylesheet">
        <link href="./assets/css/bootswatch.min.css" rel="stylesheet">
        <link href="./assets/css/font-awesome.min.css" rel="stylesheet">
        <link href="./assets/css/shCore.css" rel="stylesheet">
        <link href="./assets/css/shThemeDefault.css" rel="stylesheet">
    </head>

    <body>
        <!-- navigation -->
        <div class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
              <a href="" class="navbar-brand">The Beginner's Guide to the UNIXverse</a>
              <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
            </div>
            <div class="navbar-collapse collapse" id="navbar-main">
              <ul class="nav navbar-nav">
                <li>
                  <a href="./">Home</a>
                </li>
                
                
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">Lessons <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li>
                          <a href="./intro.html">Introduction</a>
                        </li>
                        
                        <li>
                          <a href="./filters.html">UNIX Filters</a>
                        </li>
                        
                        <li class="active">
                          <a href="./regex.html">Regular Expressions</a>
                        </li>
                        
                        <li>
                          <a href="./scripts.html">Shell Scripting</a>
                        </li>
                        
                        
                        <li>
                          <a href="./solutions.html">Solutions</a>
                        </li>
                    </ul>
                </li>
                    
                <li>
                  <a href="./tips.html">Tips</a>
                </li>
              </ul>

              <ul class="nav navbar-nav navbar-right">
                <li><a href="http://compclub.com.au/" target="_blank">CompClub</a></li>
              </ul>

            </div>
            </div>
        </div>

        <!-- content -->
        <div class="container">
            <!-- hello everybody-->
            <div class="jumbotron" style="margin-top: 30px">
                <h1>
                    <span class="fa-stack">
                      <i class="fa fa-square fa-stack-2x"></i>
                      <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
                    </span>

                    Regular Expressions
                </h1>
            </div>
        
            <div>
                <div class="page-header">
                    <h1>
                        What's a regular expression?
                    </h1>
                </div>
                <p>A <em>regular expression</em> is a pattern to match strings against. (You may see it abbreviated as regex or regexp.)</p>
                <p>Regular expressions are very useful for searching for particular strings that you want. For example, let's say that you have a list of your fellow classmates' names. Let's also say that you hate all Olivers in the world, and want to find out which of your classmates has the name Oliver, so you can take their lunch money. (This approach is a bit flawed, and taking peoples' lunch money is mean, but no matter.)</p>

                <div class="row">
                    <div class="col-md-8">
                        <p>In this case, the pattern you would use would be <code>Oliver</code>. This pattern would simply return everyone who had Oliver in their name. In case it isn't obvious, such a pattern for the list on the right would give back the names -</p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Results for pattern <code>Oliver</code></strong>
                            </div>
                            <div class="panel-body">
                                <p>Oliver Fan</p>
                                <p>Oliver Thanh</p>
                                <p>Oliver Petrol</p>
                            </div>
                        </div>
                        <p>Similarly, using a pattern of <code>Pucas</code> would return </p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Results for pattern <code>Pucas</code></strong>
                            </div>
                            <div class="panel-body">
                                <p>Pucas Lickup</p>
                            </div>
                        </div>
                        <p>and so on.</p>
                        <p>
                    </div>
                    <div class="col-md-4">
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Sekrit List of Classmates' Names</strong>
                            </div>
                            <div class="panel-body">
                                <p>Pucas Lickup</p>
                                <p>Oliver Fan</p>
                                <p>Mr Inal</p>
                                <p>Doge Superior</p>
                                <p>Oliver Thanh</p>
                                <p>Ke$ha</p>
                                <p>Oliver Petrol</p>
                                <p>Pear Pestephan</p>
                                <p>Lavandar Khan</p>
                                <p>North Best</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="alert alert-info">
                    <i class="fa fa-lightbulb-o"></i> <strong> Note:</strong> In this example, we've used whole first names as a search pattern. However, should we only search for a subsection of a name - for example, <code>liver</code> instead of <code>Oliver</code>, it will still return the same results <strong>DONT LIKE THE WORDING OF THIS</strong>. A string matches a regular expression if the expression is contained in the string.
                </div> 
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Regular Expressions and UNIX
                    </h1>
                </div>
                In UNIX, we can use the <code>grep</code> utility to perform searches for lines matching a regular expression. The basic syntax we use is:
                <p><pre class="brush:bash; gutter:false">$ grep [OPTIONS] PATTERN [FILE]</pre></p>
                <p>We don't have to specify files for it to search against. We can omit the <code>[FILE]</code> option, or instead use a hyphen <code>-</code>. This tells <code>grep</code> to read from standard input. So we can specify a pattern, and then we will be prompted to enter input. After pressing the enter key, grep will print out that line again with matching parts highlighted if it matches the regex you specified.</p>
                

                <div class="row">
                    <div class="col-md-8">
                        <p>Let's return to our example of petty lunch-money-stealing. This time, we'll get <code>grep</code> to do our pattern matching for us. Download the names <a href="./names">here</a>, and save them into a folder you can easily access. Next, open up a terminal (if you don't have one open already) and navigate to the folder containing the file you just downloaded. Now, it's time to enter our command. Our pattern is <code>Oliver</code>, and the file we want to search through is called <code>names</code>. This should be fairly self explanatory:</p>
                        <pre class="brush:bash; gutter:false">$ grep Oliver names</pre>
                        <p>Enter the command. </p>
                        <p>The terminal should give you back results exactly identical to those identified earlier with the same pattern (unless this content's writer is lacking in the head). Note that <code>grep</code> highlights the matching part of the string:</p>
                        <pre>$ grep Oliver names
<strong style="color:red">Oliver</strong> Fan
<strong style="color:red">Oliver</strong> Thanh
<strong style="color:red">Oliver</strong> Petrol</pre>
                        <p>This comes in extremely handy when trying to figure out what's wrong with a pattern that isn't working.</p>
                        <p>If you like, you can add extra names to the <code>names</code> file and verify that <code>grep</code> is indeed working and isn't merely fluking it. You can also change the pattern used and see what output you get!</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note:</strong> Say that you want to search for someone with a dollar sign in their name. What happens if you use the command <code>grep $ names</code>? Do you get the results you expect?
                        </div>
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note 2:</strong> There is another way you can get <code>grep</code> to search through the specified file. You can use UNIX filters, although in this case it's clearly not very efficient: <code>cat names | grep Oliver</code>. In this case, the contents of <code>names</code> are being sent to standard output, and piped into <code>grep</code>. Since we haven't specified a file for <code>grep</code> to use, it uses the provided text from standard input - in this case, whatever's in <code>names</code>.
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Different Flavours of <code>grep</code>
                    </h1>
                </div>
                <p>Let's sidestep for a bit, and take a look at the manpage for <code>grep</code>. Note that there are several variants of <code>grep</code> - some of these you will use, some not:</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Program</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>grep</code></td>
                            <td>Our regular ol' regular expression program. (It may interest you to know that it stands for <strong><em>g</em></strong>lobal search and <strong><em>rep</em></strong>lace.)</td>
                        </tr>
                        <tr>
                            <td><code>egrep</code></td>
                            <td>The same thing as if you'd typed <code>grep -E</code>. What's the <code>-E</code>, you ask? It tells <code>grep</code> to interpret the pattern as an extended regular expression - that is, it supports additional expressions in your pattern. More on this later! <strong>This doesn't make sense. Pls fix later myself/someone else.</strong></td>
                        </tr>
                        <tr>
                            <td><code>fgrep</code></td>
                            <td>The same thing as if you'd typed <code>grep -F</code>. The <code>-F</code> flag allows you to specify as a pattern as a list of strings, separated by newlines, any of which is to be matched. (Yes, this was taken straight from the manpage.)</td>
                        </tr>
                        <tr>
                            <td><code>rgrep</code></td>
                            <td>You probably won't use this as often as the others - it will read all the files under each directory recursively.</td>
                        </tr>
                    </tbody>
                </table>
                <div class="row">
                    <div class="col-md-4">
                        <img src="./assets/pictures/perl_camel.jpg" class="img-rounded">
                    </div>
                    <div class="col-md-8">
                        <p>In this lesson, we'll be using extended regular expressions. These give us more features than basic regular expressions, and can make life a bit easier! To use extended regular expressions, as you may have guessed from above, we just need to add the <code>-E</code> option to our command. You can also use <code>egrep</code>, however, its use is deprecated.</p>
                    </div>
                </div>
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Flags
                    </h1>
                </div>
                <p>There are also some very useful flags for <code>grep</code> that we can use. (I won't list them all; you can read the manpage yourself if you're a very keen bean.)</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Flag</th>
                            <th>Description</th>
                        </tr> 
                        <tr>
                            <td><code>-i</code></td>
                            <td>This option ignores case when matching - so if you were to specify a pattern</p>
                            <pre class="brush:bash; gutter:false">$ grep -i fresh random_file</pre>
                            <p>then it would find any strings containing the word <code>fresh</code>, whether its letters were capitalised or not.</p>
                            </td>
                        </tr>
                        <tr>
                            <td><code>-v</code></td>
                            <td>Instead of returning all lines that match, it returns all the lines that don't match. So going with the above example, the command </p><pre class="brush:bash; gutter:false">$ grep -v fresh random_file</pre>
                                <p>would return all lines in the file that didn't have fresh in them.</p></td>
                        </tr>
                        <tr>
                            <td><code>-c</code></td>
                            <td>This option will tell <code>grep</code> to output the number of matches for each input file, rather than to output the matching lines themselves.</p></td>
                        </tr>
                    </tbody>
                </table>
                <div class="row">
                    <div class="col-md-6">
                        <div class="panel panel-primary">
                            <div class="panel-heading">
                                <strong>Exercise Eins</strong>
                            </div>
                            <div class="panel-body">
                                <p>Thank god you're here! Oliver's mother has just rung us to tell you that someone has taken his lunch money! She's very upset, and would like someone to find out the names of the classmates who could've taken his money (Oliver refuses to tell her who it was). She knows that it wasn't any of the Olivers, as they're all friends.</p>
                                <p>Write a grep command that finds all the people who could've taken Oliver's lunch money, so the thief can be brought to justice.</p>

                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="panel panel-primary">
                            <div class="panel-heading">
                                <strong>Exercise Zwei</strong>
                            </div>
                            <div class="panel-body">
                                <p>Thank god you're here again! Oliver has just recently acquired an obsession with the word "south". He'd like to find out how many words in the file <code>/usr/share/dict/words</code> contain the word "south" in it, and he doesn't care if some of the letters are capitalised.</p>
                                <p>Write a grep command that counts the number of words in <code>/usr/share/dict/words</code> (you can just use this as the file name - it's included on the computer) which contain the word "south", case-insensitive.</p>
                            </div>
                        </div>
                    </div>
                </div>                
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Regex Basics
                    </h1>
                </div>
                <div class="row">
                    <div class="col-md-8">
                        <p>Now that <code>grep</code> and friends have been introduced, let's get into the meatiness of regex. In this section, basic expressions for patterns will be introduced. Throughout this lesson, we'll be using <code>/usr/share/dict/words</code>, a file of around 100000 words, to test out our regex patterns.</p>
                        <p>First and foremost, the most intuitive part of regex is that a letter will only match itself. Naturally, if we specify a pattern <code>a</code>, it will match the letter <code>a</code>. If we have a pattern <code>aa</code>, it will match anything containing <code>aa</code>, and so on. This should be highly intuitive.</p>

                        <p>A character matching against itself is all well and good, but leaves a little to be desired. What if you don't care about what a particular character is? Well, happily, there's also a character for that. The <code>.</code> (a full stop) character will match any character. So the pattern <code>.</code> will match any word you compare against it - it matches lines with at least one character in it.</p>
                        


                        <p>Next up are some quantifiers. Quantifiers specify how many of a particular character/group are to be matched.</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <p><i class="fa fa-lightbulb-o"></i> <strong>Note: </strong>Recall that arguments in bash are passed differently depending on whether there are quotes around them or not. If we do not enclose the pattern in quotes, then the shell will attempt to interpolate variables and special shell metacharacters will be interpreted. This can have interesting (read: frustrating) effects when using these special characters.</p>
                            <p>If we enclose the pattern in single quotes - <code>'I love the $north'</code>, the shell will not touch the pattern. If we enclose it in double quotes - <code>"I love the $north"</code>, the shell will attempt to replace variables (in shell, variables begin with $ when being referenced. In this case, $north will be replaced by its respective value).</p>
                        </div>
                    </div>
                </div>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Character</th>
                            <th>Description</th>
                        </tr> 
                        <tr>
                            <td><code>*</code></td>
                            <td>Putting this after a character tells the regex to match zero or more repetitions of the character. For example, if we test out the pattern <code>t*</code> using the command <code>grep "t*" /usr/share/dict/words</code>, we'll get back the entire file! This is because the asterisk also allows the matching of zero occurrences of the character.</p></td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td><p>Sometimes, you don't want to allow a character to be matched zero times. That's okay, there's another character we can use. The <code>+</code> character matches its preceding character 1 or more times. This character is not included in basic regular expressions, so you'll need <code>-E</code> to use this one.</p></td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td>This one matches the previous character either once, or not at all. This one's also not part of basic regular expressions.</p></td>
                        </tr>
                    </tbody>
                </table>
                <p>These characters have other functions:</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Character/s</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>()</code></td>
                            <td><p>The parentheses are used for grouping. For example, the pattern <code>a(,a)*</code> accepts comma separated lists of <em>a</em>s.</p></td>
                        </tr>
                        <tr>
                            <td><code>|</code></td>
                            <td>This symbol you may have seen before: it acts as an <em>or</em>. So if you have a pattern <code>north|south</code>, it would accept <code>north</code> or <code>south</code>.</td>
                        </tr>
                    </tbody>
                </table>

            </div>
            <div>
                <div class="page-header">
                    <h1>
                        Anchors
                    </h1>
                </div>
                <p>Now we'll introduce some extremely useful metacharacters - the <code>^</code> and <code>$</code> characters. The caret (<code>^</code>) specifies that whatever follows it <em>must</em> be at the start of the line. So for example, if we wanted to <em>ensure</em> that we search for Oliver as a first name only, then we have the pattern as</p>
                <pre class="brush:bash; gutter:false">$ grep "^Oliver" names</pre>
                <p>The dollar sign (<code>$</code>), in a similar fashion to the caret, specifies that whatever comes before it must be at the end of the word. So if we wanted to only accept lines that had "Oliver" in them, then we would use the command</p>
                <pre class="brush:bash; gutter:false">$ grep "^Oliver$" names</pre>
                <p>(In either of these cases, we didn't need to wrap quotes around the pattern, but it's good practice to just in case your pattern does have characters that can be interpreted by the shell.)</p>
                <p>Let's look at at a couple of examples of anchor usage. Let's say that we want to look for all words that begin with a, end with z, and have at least one character in between them. Then the pattern we'd use would be - (note the <code>-E</code> flag, since we're using an extended regex character)</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^a.+z$" /usr/share/dict/words</pre>
                <p>Oh...there are no results...let's modify our pattern a bit, then. Maybe if we change it to end in y we'd get more results.</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^a.+y$" /usr/share/dict/words
abbey
ability
abjectly
ably
abnormality
...                </pre>
                <p>Woo, that worked! Now let's do a search for words that start with "capt" and end in "ing" (or you can pick a different combination, if you like). Hopefully the pattern here should be obvious:</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^capt.+ing$" /usr/share/dict/words
captaining
captioning
captivating
capturing</pre>
                <p>Hopefully, you should get the same results as we did here.</p>


            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Bracket Expressions
                    </h1>
                </div>
                <p>What's a bracket expression?</p>
                <ul>
                    <li>It's denoted by [<em>list of characters</em>]</li>
                    <li>It will match any single character from the list of characters.</li>
                </ul>
                <p>For example, <code>[aeiou]</code> will match any vowel.</p>
                <div class="row">
                    <div class="col-md-8">
                        <p>You might think that, then, in order to get (for example) the numbers zero to nine, you'd have to go <code>[0123456789]</code> in your pattern. But luckily, there's a nice shorthand for ranges of characters like these - <code>[0-9]</code>. Similarly, you can also use <code>[a-z]</code>, <code>[A-Z]</code> or even <code>[a-m]</code> or another section of the alphabet or numbers. You can even chain them together like <code>[a-zA-Z0-9]</code> - this will match any alphanumeric number.</p>
                        <p>Sometimes, you might want to match any character <em>except</em> anything that's in the list. That's fine! Simply add a <code>^</code> after the first bracket. For example, if I wanted to exclude all the numbers then I would use <code>[^0-9]</code>.</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note: </strong>One useful range you could use is <code>[ -~]</code> - this will match any printable character.
                        </div>
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note 2: </strong>Punctuation characters lose their special meaning when they're inside bracket expressions.
                        </div>
                    </div>

                </div>

                <div>
                    <div class="page-header">
                        <h1>
                            Regex Behaviour
                        </h1>
                    </div>
                    <p>Regex behaves in a certain way, and it would be of benefit to you to learn how it does.</p>
                    
                    <p><strong><em>Me first: </em></strong>If a pattern can match multiple parts of the input, then the first match will be chosen. For example if you had a pattern <code>[0-9]+</code> and a string of <code>1234 5678</code>, then it would match the <code>1234</code> and not the <code>5678</code>.</p>

                    <p><strong><em>Greedyguts: </em></strong>By default, regex is <em>greedy</em>. This means that it will try to match as much of the string as possible. Note that with the example in the previous point that it matched as much of it as it could - so, <code>1234</code> instead of <code>1</code>. Simplying matching the <code>1</code> would have been <em>non-greedy</em>. If we wanted a particular quantifier to be non-greedy, we just need to put a question mark after it. So for the previous example, we would have the pattern <code>[0-9]+?</code> and this would match only the <code>1</code>.</p>

                    <p><strong><em>The great escape: </em></strong>Sometimes, you probably won't want the special meaning of <code>[</code>, <code>]</code> or any other special character - you'll want to search for it literally. In this case, you preface the character with a backslash:</p>
                </div>
                                    <pre class="brush:bash">$ echo "[]" > example
$ cat example
[]                                    
$ grep "[]" example
grep: Unmatched [ or [^
$ grep "\[\]" example
[]</pre>
                                    <p>As you can see, searching for the square brackets on their own isn't going to do you any good. However, escaping the respective brackets tells <code>grep</code> to search for a bracket literal. This is the reason why our earlier command <code>grep $ name</code> wasn't very useful.</p>                                      
            <div>
                <h2>Exercises</h2>
                <hr>

                <p>On most Unix systems there's one or more dictionaries containing many thousands of words usually in <code>/usr/share/dict/</code> or <code>/usr/dict/</code>. A lot of the exercises below will use one of these dictionaries as a large base of words to search. To save repeatedly typing its full pathname for these exercises, make a symbolic link to the file with this command:</p>
                <pre class="brush:bash">
ln -s /home/cs2041/public_html/lab/sh/dictionary/words.txt mywords
                </pre>
                <p>(this creates a file in the current directory pointing to the original file, without taking up the space of a complete copy)</p>

                <div class="row">
                    <h4>Less/Grep Practice</h4>
                    <ol>
                        <li>Use Less and its commands to find these words.</li>
                        <ol type="a">
                            <li>What word is on line 2000?</li>
                            <li>Find the first word in the dictionary file ending with z.</li>
                            <li>Find the last word in the dictionary that contains the substring ooz.</li>
                        </ol>
                        <li>There are a small number of English words that have all the vowels occuring in order. Find the first one of these using less, then quit the viewer (q command) and with the same regexp, use grep to find them all. Note: the word may contain more than 5 vowels but it must contain aeiou in that order.</li>
                        <ol type="a">
                            <li>Look at the output from the grep above. What are the first, the last and the longest words, which have all the vowels in this order, 'aeiou'?
                                <div class="collapse" style="color:green;">
                                    <p><b>Answer:</b></p>
                                    Command: <code>grep 'a.*e.*i.*o.*u' mywords</code>
                                    Words:
                                    <pre>
abstemious
...
supercalifragilisticexpialidocious
...
valerianaceous
</pre>
                                </div>
                            </li>
                            <li>How many are there?
                                <div class="collapse" style="color:green;">
                                    <p><b>Answer:</b></p>
                                    <p>Command: <code>grep 'a.*e.*i.*o.*u' mywords | wc</code></p>
                                    <pre>
53  53  785
</pre>
                                </div>
                            </li>
                            <li><strong><em>Challenge</em></strong>, modify the regex so it matches only words containing exactly 5 vowels and the vowels are in order (aeiou).
                                <div class="collapse" style="color:green;">
                                    <p><b>Answer:</b></p>
                                    <p>Command: <code>grep '^[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*$' mywords</code></p>
                                    <pre>
abstemious
abstemiously
abstentious
arsenious
caesious
facetious
facetiously
</pre>
                                </div>
                            </li>
                        </ol>
                    </ol>
                </div>

                <div class="row">
                    <h4>Basic Pipelining</h4>
                    <p>Write shell pipelines using grep, cat and wc which answer the following
                    questions.  Provide both the command/pipeline and its output.</p>
                    <ol type="a">
                        <li>How many total words does the file mywords contain?
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>wc -w mywords</code> <br>
                                Output: 390582
                            </div>
                        </li>
                        <li>Note that some of these words are derivates of other words (e.g. "Aberdeen" and "Aberdeen's"). Maybe these shouldn't be included in the word count. How many total words, excluding those ending in "'s", are there in the dictionary?
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>grep -v "'s$" mywords | wc -w</code> <br>
                                Output: 299845
                            </div>
                        </li>
                        <li>How could you use cat -n and grep to find out which word is on line 100000? (You'll need to check the exact output format of cat -n.)
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>cat -n mywords | grep '^100000'</code> <br>
                                Output: 100000  adviser <br>
                                Note that each line coming out of the cat starts with some spaces, followed by a number, followed by a TAB character. You can explicitly match the TAB if you want, but you'll need to type control-V followed by TAB in order to get a TAB to appear in the command line.
                            </div>
                        </li>
                        <li>How could you use cat -n and grep to print the 700th line, and no other lines? (You'll need to check the exact output format of cat -n.)
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>cat -n mywords | grep '^ *700[^0-9]'</code> <br>
                                Output:    700  Adirondack <br>
                            </div>
                        </li>
                        <li>How do you use head and tail to find out what word is on line 200000?
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>head -200000 mywords | tail -1</code> <br>
                                Output: geodynamics's
                            </div>
                        </li>
                    </ol>
                </div>

                <div class="row">
                    <h4>Dictionaries bow down to GREP!</h4>
                    <p>Consider how we might locate various "unusual" words in the dictionary using grep (or egrep or fgrep):</p>
                    <ol type="a">
                        <li>Which words contain the characters "lmn" consecutively?
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>grep 'lmn' mywords</code> <br>
                                Output:
                                <pre>
Selmner
Selmner's
almner
almners
calmness
calmness's
calmnesses
</pre>
                            </div>
                        </li>
                        <li>How many words contain "zz", but do not end in apostrophe-s ('s)? 
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>grep 'zz' mywords | grep -v "'s$" | wc</code> <br>
                                or <br>
                                Command: <code>grep 'zz' mywords | grep -c -v "'s$"</code> <br>
                                Output: 628
                            </div>
                        </li>
                        <li>How many words contain four consecutive vowels? 
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                Command: <code>grep '[aeiou][aeiou][aeiou][aeiou]' mywords | wc</code> <br>
                                or <br>
                                Command: <code>egrep -c '[aeiou]{4}' mywords</code> <br>
                                Output: 205
                                <br> 
                                <br>
                                or ignoring case: <br>
                                Command: <code>grep '[aeiouAEIOU][aeiouAEIOU][aeiouAEIOU][aeiouAEIOU]' mywords | wc</code> <br>
                                or <br>
                                Command: <code>egrep -ic '[aeiou]{4}' mywords</code> <br>
                                Output: 207
                            </div>
                        </li>
                        <li>Still on words, we want to know how many words have another 9-letter dictionary word embedded in them.
                            <p>Place all the 9-letter words in the dictionary in a file called words9. How to do this? Use a grep pattern anchored at both ends, that matches exactly 9 characters of any kind. Redirect the output of the command using the &gt; shell notation. How many of these words are there?</p>
                            <p>Now we want to use the list of words as a (huge) search pattern. fgrep uses a highly optimised algorithm to do this. Its usage is:</p>
                            <pre class="brush:bash">
fgrep -f WordListFile files...
</pre>
                            <p>However, we aren't interested in words that have any non-letter in them, to avoid matching possessives like Bernouilli's. We also don't want to match lines that are exactly 9 characters long either.</p>
                            <p>
                            <p><strong>Devise</strong> a pipeline that uses your word list (words9) and the original file to count the number of words composed of letters only that have a different 9-letter word as a substring. For example "luminesce" is a substring of "photoluminescence".</p>
                            <p>Note there are a small number of non-English words in the dictionary which have <a href="http://en.wikipedia.org/wiki/Diacritic">diacritical marks</a> which are encoded as a separate character in ASCII - your regular expressions don't need to handle these correctly.</p>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <pre class="brush:bash">
# Create the words9 file
# Note that this ignores words ending in 's

egrep '^[a-z]{9}$' mywords &gt; words9

# Get the words containg these as a substring
# First stage: extract all words that contain a "words9" word as a
#              substring or are equal to a "words9" word
# Second stage: eliminate all nine-character words (i.e. drop all
#              of the extracted words that come from the "words9" file)

fgrep -f words9 mywords | egrep -v '^[a-z]{9}$'
</pre>
                            <p>There are 39503 such words (run the above through wc -w).</p>
                            </div>
                        </li>
                    </ol>
                </div>

                <div class="row">
                    <h4>Extraodinary Extra egrep Exercises</h4>
                    <ol type="a">
                        <li>Write a regular expression for egrep that matches any line containing at least one A and at least one B. For example:
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="table table-bordered table-striped">
                                        <tbody>
                                            <tr><th>Matching</th>                       <th>Not Matching</th></tr>
                                            <tr><td>Andrew's favourite Band is not</td> <td>George is Brillant</td></tr>
                                            <tr><td>ABBA</td>                           <td>Andrew</td></tr>
                                            <tr><td>BA</td>                             <td>B</td></tr>
                                            <tr><td>AB</td>                             <td>A</td></tr>
                                        </tbody>
                                    </table> <br>
                                </div>
                            </div>
                            <p>So to test with egrep you might do this:</p>
                            <pre class="brush:bash">
% cat &gt; file1 &lt;&lt; eof
Andrew's favourite Band is not
George is Brillant
ABBA
Andrew
AB
BA
A
B
eof
% egrep 'REGEXP' &lt; file1
Andrew's favourite Band is not
ABBBAB
AB
BA
</pre>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <pre class="brush:bash">A.*B|B.*A</pre>
                            </div>
                        </li>
                        <li>Write a regular expression for egrep that matches any line containing only the characters A and B such that all pairs of adjacent A's occur before any pairs of adjacent B's. In other words if there is pair of B's on the line, there can not be a pair of A's afterwards.
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="table table-bordered table-striped">
                                        <tbody>
                                            <tr><th width="50%">Matching</th>   <th width="50%">Not Matching</th></tr>
                                            <tr><td>ABAABAABAABBBBABB</td>      <td>BBAA</td></tr>
                                            <tr><td>ABBA</td>                   <td>ABBAA</td></tr>
                                            <tr><td>ABAAAAAAAAAABBA</td>        <td>ABBABABABABAA</td></tr>
                                            <tr><td>ABABABABA</td>              <td>ABBBAAA</td></tr>
                                            <tr><td>A</td>                      <td>BBABABABABABABAA</td></tr>
                                        </tbody>
                                    </table> <br>
                                </div>
                            </div>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <pre class="brush:bash">^(BA|A)*(|B)(AB|B)*(|A)$</pre>
                                <p>or courtesy Squish:</p>
                                <pre class="brush:bash">^(BA|A)*(BA|B)*$</pre>
                            </div>
                        </li>
                        <li>Write a regular expression  for egrep that matches any line containing only the characters A and  B such that the number of A's is divisible by 4.
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="table table-bordered table-striped">
                                        <tbody>
                                            <tr><th width="50%">Matching</th>   <th width="50%">Not Matching</th></tr>
                                            <tr><td>AAAA</td>                   <td>AAAAA</td></tr>
                                            <tr><td>BABABABAB</td>              <td>ABABBBBBBBBBBBBBBBAAA</td></tr>
                                            <tr><td>AAAABBBBAAAA</td>           <td>AAAABBABBAAAA</td></tr>
                                            <tr><td>BBBAABBBBBAABBBAAAA</td>    <td>BBBAABBABBBAABBBAAAA</td></tr>
                                        </tbody>
                                    </table> <br>
                                </div>
                            </div>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <pre class="brush:bash">^B*(AB*AB*AB*AB*)*$</pre>
                            </div>
                        </li>
                        <li>Write a regular expression for egrep  that matches any line containingonly the characters A and  B such thatthere are exactly <em>n</em> A's followed byexactly <em>n</em> B's and no other characters.
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="table table-bordered table-striped">
                                        <tbody>
                                            <tr><th width="50%">Matching</th>   <th width="50%">Not Matching</th></tr>
                                            <tr><td>AAABBB</td>                 <td>AAABB</td></tr>
                                            <tr><td>AB</td>                     <td>BA</td></tr>
                                            <tr><td>AABB</td>                   <td>AABBB</td></tr>
                                            <tr><td>AAAABBBB</td>               <td>AAAABBBBA</td></tr>
                                        </tbody>
                                    </table> <br>
                                </div>
                            </div>
                            <p>If you can't invent a regular expression, can you write a shell script using egrep, sed and test, if &amp; while which performs the same task.</p>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <p>This can't be done with a (true) regular expression. You prove this via the the wonderfully named <a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages">pumping lemma</a>.</p>
                                <p>It is possible <a href="http://faq.perl.org/perlfaq6.html#Can_I_use_Perl_regulextension"> with extensions to the regular expression language provided in languages such as Perl </a>.</p>
                                <pre class="brush:bash">
grep "^A*B*$" |
sed "s/\(A*\)\(B*\)/|/;s/B/A/g" |
sed -n "s/^\(A*\)|$/|/p" |
sed -n "s/^\(A*\)|\(A*\)$/|/gp" |
sed "/|/ s/A/B/g" |
sed "N; s/|//"
</pre>
                            </div>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <p>Shell script which prints line containing n As followed by n B's</p>
                                <pre class="brush:bash">
#!/bin/sh
while read line
do
    string="$line"
    while test -n "`echo "$string" | egrep '^A.*B$'`"
    do
        string=`echo "$string" | sed 's/^A//'`
        string=`echo "$string" | sed 's/B$//'`
    done
    test -z "$string" &amp;&amp; echo "$line"
done
</pre>
                            </div>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <p>Grep &amp; sed script which prints line containing n As followed by n Bs</p>
                                <pre class="brush:bash">
#!/bin/sh
# written by Alexis Shaw
grep "^A*B*$" |
sed "s/\(A*\)\(B*\)/\1|\2/;s/B/A/g" |
sed -n "s/^\(A*\)|\1$/\1|\1/p" |
sed -n "s/^\(A*\)|\(A*\)$/\1\n|\1/gp" |
sed "/|/ s/A/B/g" |
sed "N; s/\n|//"
</pre>
                            </div>
                            <div class="collapse" style="color:green;">
                                <p><b>Answer:</b></p>
                                <p>Sed statment which prints line containing n As followed by n B's</p>
                                <pre class="brush:bash">
sed '/^A*B*$/!dhs/\(B*\)$/C\1/s/B/A/g/^\(A*\)C\1$/!dg'
</pre>
                            </div>
                        </li>
                    </ol>
                </div>
            </div>

                grep, egrep, regex, eregex, perl regex (use perl regex)

                regex basics
                - ^$
                - . ? *

                regex greedy/non-greedy (e.g. '.*?')


                grep -o -i options


                s// with \1 \2 etc

                examples using find
                e.g. find -R . | grep lol

            <!-- footer -->
            <footer>
                <div class="row">
                    <div class="col-lg-12">         
                        <p class="pull-right"><a href="#"><i class="fa fa-caret-up"></i> Back to top</a></p>
                        <p>Part of the <a href="http://cse.unsw.edu.au/">UNSW CSE</a> Summer Workshops, on behalf of <a href="http://www.compclub.com.au">CompClub</a>.</p>
                        <p>Workshop content written by <a href="http://cgi.cse.unsw.edu.au/~otan/">Oliver Tan</a>, <a href="http://cgi.cse.unsw.edu.au/~vanessau/">Vanessa Ung</a> and <a href="http://cgi.cse.unsw.edu.au/~lpickup">Lucas Pickup</a>.</p>
                    </div>
                </div>
            </footer>

        </div> <!-- container -->

        <script src="./assets/js/jquery.js"></script>
        <script src="./assets/js/bootstrap.min.js"></script>
        <script src="./assets/js/shCore.js"></script>
        <script src="./assets/js/shBrushBash.js"></script>
        <script type="text/javascript">SyntaxHighlighter.all();</script>
    </body>
</html>


